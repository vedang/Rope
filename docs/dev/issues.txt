=============
 Rope Issues
=============


Unresolved Issues
=================

* custom restructuring wildcard patterns and replacements
* not reimporting back imports after moving
* importing compressed objectdb/history data?
* not applying all commenting mechanisms always in codeassist
* fixing try blocks before current line in code_assist
* searching all files when extracting a global method?
* better tests in `patchedasttest`
* import actions with more that one phase and filtering problems
* handle long imports should work on filtered imports unconditionally?
* adding restructuring scope; local scope, module, all files?
* changing `codeanalyze.WordFinder` to use asts?
* assignment to parameters in inline method
* extracting subexpressions; look at `extracttest` for more info
* remove ``change occurreces`` refactoring?
* using similarfinder in introduce_parameter?
* switching to gplv3?
* removing unused refactorings?
* assignments and overwriting parameter, imported and evaluated names
* unignored files that are not under version control
* multiple ropes on one project; problems for objectdb and history
* should `rope.base` be thread safe?
* inline fails when there is an arg mismatch
* evaluate function parameter defaults in staticoi?
* recursive soi; go where the calls go with limited depth
* adding ``do when unsure`` config to all refactorings?
* importing star and removing self imports; stack overflow
* adding contributors file?
* saving diffs instead of old contents in ChangeContents?
* python c extensions
* supporting modules without source code and zip imports
* extract class
* analyzing function decorators
* generate ... and implicit interfaces
* generate method and class hierarchies
* lambdas as functions; consider their parameters
* renaming similarly named variables
* handling the return type of ``yield`` keyword
* extracting methods from pieces with only one return/yield statement
* not writing unchanged objectdb and history?


To Be Reviewed
==============

* lots of estimations in codeanalyze in WordRangeFinder and
  ScopeNameFinder
* review objectdb modules
* how concluded data are held for star imports


Insert Before In Restructurings
===============================

Consider a restructuring like this::

  pattern: ${?a} if ${?b} else ${?c}
  goal: replacement
  before: if ${?b}:\n    replacement = ${?a}\nelse:\n    replacement = ${?c}


Memory Management
=================

These are the places in which rope spends most of the memory it
consumes:

* PyCore: for storing PyModules
* ObjectInfo: for storing object information
* History: for storing changes

We should measure the amount of memory each of them use to make
decisions.


Custom Restructuring Wildcards
==============================

There is a need to add more custom wildcards in restructuring
patterns.  For instance, one might want to match any parameters such
as in::

  pattern: ${?obj}.f(${%params})

where ``${%params}`` should match all of the parameters that are
passed to `f()`.  But adding all such needs to `similarfinder` module
makes it really complex.  So I think adding the ability to extend them
is useful.

Sometimes wildcards can be customized.  For instance
``${%params:p1,p2}`` should match any parameters only if p1 and p2
appear in it.


Wildcard Format
---------------

This format should be easy to recognize.  Candidate:

* ``name``: match name
* ``?name``: match any name
* ``%name:args``: match a custom wildcard with args
* ``%name>wtype:args``: match `wtype` custom wildcard with args

Issues:

* Is there any need to start custom wildcards with a hash sign?
* Maybe we can put checks inside args, too::

    pattern: ${?project:type=rope.base.project.Project}.pycore

* Or maybe we can put args in a separate location, like::

    pattern: ${?obj}.f({%param>args})
    args: ?obj: type=mod.C
          %param: p1

* What should we do when a variable appears twice.  Which
  of the args should be considered? like:

    pattern: ${?a:type=__builtin__.int} + ${?a}

* Should replacements accept args, too::

    # match f when p1 is passed to it
    pattern: ${?obj}.f({%param>args:p1})
    # pass p2=23 and remove p1 parameter
    goal: ${?obj}.f({%param>args:+p2=23,-p1})

  If so, each replacement occurrence should have its own args.


Implementation
--------------

Matchers should update matched mappings and also they should be
informed about wildcard arguments.  We probably have to introduce a
`MatchContext` object.

Sample code::

  class WildcardPattern(object):

      name = None

      def does_apply(self, node):
          """Return `True` if `node` it applies"""

      def matches(self, node, mapping):
          """Return True if matches"""


  class WildcardReplacement(object):

      def does_apply(self, node, match):
          """Return `True` if `node` it applies"""

      def replacement(self, node, match):
          """Return the replacement string"""


Getting Ready For Python 3.0
============================

This has been moved to a separate branch.
